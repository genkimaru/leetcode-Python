这里我们实现三种深度优先遍历的方法:前序遍历、中序遍历和后序遍历。
这个实现使用了`栈(list)`来实现`深度优先遍历`。算法的流程如下:

## 前序遍历:
首先判断根节点是否为空,如果为空则返回一个空列表。
创建一个空列表来存储遍历结果,以及一个栈。
将根节点压入栈中,然后开始循环,直到栈为空。
在每次循环中,从栈中弹出一个节点,将其值添加到结果列表中,然后将其右子节点和左子节点(如果存在)依次压入栈中。
最终返回结果列表。
## 中序遍历:
首先判断根节点是否为空,如果为空则返回一个空列表。
创建一个空列表来存储遍历结果,以及一个栈。
将当前节点设置为根节点,然后开始循环,直到当前节点为空且栈为空。
在每次循环中,如果当前节点不为空,则将其压入栈中,并将当前节点设置为其左子节点。
如果当前节点为空,则从栈中弹出一个节点,将其值添加到结果列表中,并将当前节点设置为其右子节点。
最终返回结果列表。
## 后序遍历:
首先判断根节点是否为空,如果为空则返回一个空列表。
创建一个空列表来存储遍历结果,以及一个栈。
将根节点压入栈中,然后开始循环,直到栈为空。
在每次循环中,从栈中弹出一个节点,将其值添加到结果列表的开头。
然后将该节点的左子节点和右子节点(如果存在)依次压入栈中。
最终返回结果列表。
这些算法的时间复杂度都为O(n),其中n是二叉树的节点数量,因为我们需要访问每个节点一次。空间复杂度为O(n),因为在最坏情况下,我们需要在栈中存储所有的节点。